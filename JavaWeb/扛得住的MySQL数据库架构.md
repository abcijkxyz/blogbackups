[参考](https://segmentfault.com/a/1190000013672421)
## 第1章 实例和故事
#### 1-2 在双11大促中的数据库服务器
> 并发量：同一时间处理的请求的数量

> QPS：Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。

>TPS：是Transactions Per Second的缩写，也就是事务数/秒。它是软件测试结果的测量单位。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。

#### 1-3 在大促中什么影响了数据库性能
- 影响数据库查询速度的四个因素
![图片.png](https://upload-images.jianshu.io/upload_images/1956963-5d86f2e906274d6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 超高的QPS和TPS
风险：效率低下的SQL
- 大量的并发和超高的CPU使用率
大量的并发风险：数据库连接数被占满（max_connection默认100，一般把连接数设置得大一些）。
超高的CPU使用率风险：因CPU资源耗尽而出现宕机
- 磁盘IO
风险：磁盘IO性能突然下降、大量消耗磁盘性能的计划任务。解决：更快磁盘设备、调整计划任务、做好磁盘维护。
- 网卡流量：如何避免无法连接数据库的情况
风险：网卡IO被占满
解决：1.减少从服务器的数量（从服务器会从主服务器复制日志）
2.进行分级缓存（避免前端大量缓存失效）
3.避免使用select * 进行查询
4.分离业务网络和服务器网络
- Tips：最好不要在主库上数据库备份，大型活动前取消这样的计划。

#### 1-4 大表带来的问题
- 什么样的表可以称之为大表
记录行数巨大，单表超千万行
表数据文件巨大，表数据文件超过10G
- 大表的危害
1. 慢查询：**很难在短时间内过滤出需要的数据**
查询区分度低 -> 要在大数据量的表中筛选出来其中一部分数据会产生大量的磁盘io -> 降低磁盘效率
2. 对DDL影响：
**建立索引需要很长时间：**
MySQL -v<5.5 建立索引会锁表
MySQL -v>=5.5 建立索引会造成主从延迟（mysql建立索引，先在组上执行，再在库上执行）
**修改表结构需要长时间的锁表：**会造成长时间的主从延迟，影响正常的数据操作
- 如何处理数据库中的大表
1. 分库分表把一张大表分成多个小表
**难点：**
分表主键的选择
分表后跨分区数据的查询和统计
2. 大表的历史数据归档，减少对前后端业务的影响
**难点：**
归档时间点的选择
如何进行归档操作

#### 1-5 大事务带来的问题
- 什么是事务
1. 事务是数据库系统区别于其它一切文件系统的重要特性之一
2. 事务是一组具有原子性的SQL语句，或是一个独立的工作单元

- 事务的ACID属性
>原子性（atomicity)：整个事务中的所有操作要么全部提交成功，要么全部失败回滚。
定义：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败，对于一个事务来说，不可能只执行其中的一部分操作

>一致性（consistent)：银行转账的总金额不变。
定义：一致性是指事务将数据库从一种一致性状态转换到另一种一致性状态，在事务开始之前和事务结束后数据库中数据的完整性没有被破坏

>隔离性（isolation)：
隔离性要求一个事务对数据库中数据的修改，在未提交完成前对于其它事务是不可见的

SQL标准中定义的四种隔离级别：
1. 未提交读(READ UNCOMMITED) 脏读,两个事务之间互相可见；
2. 已提交读(READ COMMITED)符合隔离性的基本概念,一个事务进行时，其它已提交的事物对于该事务是可见的，即可以获取其它事务提交的数据；
3. **可重复读(REPEATABLE READ)** InnoDB的默认隔离等级。事务进行时，其它所有事务对其不可见，即多次执行读，得到的结果是一样的；
4. 可串行化（SERIALIZABLE） 在读取的每一行数据上都加锁，会造成大量的锁超时和锁征用，严格数据一致性且没有并发是可使用。
```
查看系统的事务隔离级别：show variables like '%iso%';
开启一个新事务：begin;
提交一个事务：commit;
修改事物的隔离级别：set session tx_isolation='read-committed';
```
![图片.png](https://upload-images.jianshu.io/upload_images/1956963-dac1907e9fda7148.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

>持久性(DURABILITY)：从数据库的角度的持久性，磁盘损坏就不行了
定义：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，已经提交的修改数据也不会丢失

- 大事务
>运行时间长，操作数据比较多的事务

**风险：锁定数据太多，回滚时间长，执行时间长。**
1. 锁定太多数据，造成大量阻塞和锁超时；
2. 回滚时所需时间比较长，且数据仍然会处于锁定；
3. 如果执行时间长，将造成主从延迟，因为只有当主服务器全部执行完写入日志时，从服务器才会开始进行同步，造成延迟。

**解决思路：**
1. 避免一次处理太多数据，可以分批次处理；
2. 移出不必要在事务中的SELECT操作，保证事务中只有必要的写操作。

## 第2章 什么影响了MySQL性能
#### 2-1 影响性能的几个方面
1. 服务器硬件。
2. 服务器系统（系统参数优化）。
3. 存储引擎。
MyISAM： 不支持事务，表级锁。
InnoDB： 支持事务，支持行级锁，事务ACID特性。
4. 数据库参数配置。
5. **数据库结构设计和SQL语句。（重点优化）**

#### 2-2 CPU资源和可用内存大小
- 如何选择CPU
**64位的CPU一定要工作在64位的操作系统下**
1. 我们的应用是CPU密集型的吗？
**对于并发比较高的场景CPU的数量比频率重要**
**对于CPU密集型场景和复杂SQL则频率越高越好**
MySQL不支持多CPU对同一SQL并发处理
2. 我们系统的并发量如何？
多CPU比较好
Web类应用：核心数量比频率重要
3. 我们所使用MySQL的版本
老版本的MySQL对多核的支持并不好
- 内存
MyISAM存储引擎会索引缓存到内存中，数据由OS缓存
InnoDB存储引擎会使用内存缓存索引和数据
内存越多越好，但是对性能影响有限，并不能无限的增加性能
当内存超过数据大小，不能提升性能
内存的主频最好和CPU主频类似，频率越高速度越快，
**选择主板所能支持的最高频率内存**
**内存的大小对性能很重要，所以尽可能的大**

#### 2-3 磁盘的配置和选择
1. 使用传统机器硬盘
存储容量
传输速度
访问时间
主轴转速
物理尺寸
2. 使用RAID增加传统机器硬盘的性能
3. 使用固态存储SSD和PCIe卡
4. 使用网络存储SAN和NAS

#### 2-4 使用RAID增加传统机器硬盘的性能
- 什么是RAID
RAID是磁盘冗余队列的简称
简单来说RAID的作用就是可以把多个容量较小的磁盘组成一组容量更大的磁盘，并提供 来保证数据完整性的技术

#### 2-5 使用固态存储SSD或PCIe卡
相比机械磁盘固态磁盘有更好的随机读写性能
相比机械磁盘固态磁盘能更好的支持并发
**相比机械磁盘固态磁盘更容易损坏**
- SSD
1. 使用SATA接口
可以替换传统磁盘而不需任何改变
SATA 3.0 磁盘插在 SATA 2.0 很影响速度
2. SATA接口的SSD同样支持RAID技术
- PCIe卡
1. 无法使用SATA接口
需要独特的驱动和配置
2. 价格相对于SSD要贵
但是性能比SSD更好
- 固态存储的使用场景
适用于存在大量随机I/O的场景
适用于解决单线程负载的I/O瓶颈

#### 2-6 使用网络存储SAN和NAS
SAN和NAS是两种外部文件存储设备加载到服务器上的方法
SAN设备通过光纤连接到服务器，设备通过块接口访问，服务器可以将其当做硬盘使用
NAS设备使用网络连接，通过基于文件的协议如NFS或SMB来访问
- 网络存储适用的场景
数据库备份
- 网络对性能的影响
磁盘性能的限制：延迟、吞吐量
网络性能的限制：延迟、带宽、网络质量
- 建议
采用高性能和高带宽的网络接口设备和交换机
对多个网卡进行绑定，增强可用性和带宽
尽可能的进行网络隔离

#### 2-7 总结：服务器硬件对性能的影响
- I/O子系统
PCIe -> SSD -> Raid10 -> 磁盘 -> SAN

#### 2-8 操作系统对性能的影响-MySQL适合的操作系统
#### 2-9 CentOS系统参数优化
#### 2-10 文件系统对性能的影响
#### 2-11 MySQL体系结构
#### 2-12 MySQL常用存储引擎之MyISAM
#### 2-13 MySQL常用存储引擎之Innodb
#### 2-14 Innodb存储引擎的特性(1)
#### 2-15 Innodb存储引擎的特性(2)
#### 2-16 MySQL常用存储引擎之CSV
#### 2-17 MySQL常用存储引擎之Archive
#### 2-18 MySQL常用存储引擎之Memory
#### 2-19 MySQL常用存储引擎之Federated
#### 2-20 如何选择存储引擎
#### 2-21 MySQL服务器参数介绍
#### 2-22 内存配置相关参数
#### 2-23 IO相关配置参数
#### 2-24 安全相关配置参数
#### 2-25 其它常用配置参数
#### 2-26 数据库设计对性能的影响
#### 2-27 总结

## 第3章 MySQL基准测试
#### 3-1 什么是基准测试
#### 3-2 如何进行基准测试
#### 3-3 基准测试演示实例
#### 3-4 Mysql基准测试工具之mysqlslap
#### 3-5 Mysql基准测试工具之sysbench
#### 3-6 sysbench基准测试演示实例

## 第4章 MySQL数据库结构优化
#### 4-1 数据库结构优化介绍
#### 4-2 数据库结构设计
#### 4-3 需求分析及逻辑设计
#### 4-4 需求分析及逻辑设计-反范式化设计
#### 4-5 范式化设计和反范式化设计优缺点
#### 4-6 物理设计介绍
#### 4-7 物理设计-数据类型的选择
#### 4-8 物理设计-如何存储日期类型
#### 4-9 物理设计-总结

## 第5章 MySQL高可用架构设计
#### 5-1 mysql复制功能介绍
#### 5-2 mysql二进制日志
#### 5-3 mysql二进制日志格式对复制的影响
#### 5-4 mysql复制工作方式
#### 5-5 基于日志点的复制
#### 5-6 基于GTID的复制
#### 5-7 MySQL复制拓扑
#### 5-8 MySQL复制性能优化
#### 5-9 MySQL复制常见问题处理
#### 5-10 什么是高可用架构
#### 5-11 MMM架构介绍
#### 5-12 MMM架构实例演示（上）
#### 5-13 MMM架构实例演示（下）
#### 5-14 MMM架构的优缺点
#### 5-15 MHA架构介绍
#### 5-16 MHA架构实例演示(1)
#### 5-17 MHA架构实例演示(2)
#### 5-18 MHA架构优缺点
#### 5-19 读写分离和负载均衡介绍
#### 5-20 MaxScale实例演示

## 第6章 数据库索引优化
#### 6-1 Btree索引和Hash索引
#### 6-2 安装演示数据库
#### 6-3 索引优化策略（上）
#### 6-4 索引优化策略（中）
#### 6-5 索引优化策略（下）

## 第7章 SQL查询优化
#### 7-1 获取有性能问题SQL的三种方法
#### 7-2 慢查询日志介绍
#### 7-3 慢查询日志实例
#### 7-4 实时获取性能问题SQL
#### 7-5 SQL的解析预处理及生成执行计划
#### 7-6 如何确定查询处理各个阶段所消耗的时间
#### 7-7 特定SQL的查询优化

## 第8章 数据库的分库分表
#### 8-1 数据库分库分表的几种方式
#### 8-2 数据库分片前的准备
#### 8-3 数据库分片演示(上)
#### 8-4 数据库分片演示(下)

## 第9章 数据库监控
#### 9-1 数据库监控介绍
#### 9-2 数据库可用性监控
#### 9-3 数据库性能监控
#### 9-4 MySQL主从复制监控
